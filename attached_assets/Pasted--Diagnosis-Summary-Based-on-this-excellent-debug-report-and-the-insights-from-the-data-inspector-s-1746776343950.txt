üîç Diagnosis Summary
Based on this excellent debug report and the insights from the data_inspector_screener.py, here‚Äôs what‚Äôs actually happening:

‚ùå Issue 1: Wrong Data Type
‚ÄúThe screeners expect pandas DataFrames but get dictionaries‚Äù
The app‚Äôs backend isn‚Äôt preloading stock data into data_dict as {symbol: DataFrame}.

So:

python
Copy
Edit
df = data_dict[symbol]
...is not valid, because data_dict might just be a flat {} or {symbol: {}}, not actual OHLCV data.

‚úÖ Fix: Add logic to fetch and build the DataFrames inside the screener if needed.

‚ùå Issue 2: Wrong Library Usage
ta.trend.ppo is not a valid function.

You were using the ta library (technical-analysis), but the backend actually installed and supports pandas-ta instead.

‚úÖ Fix: Switch to import pandas_ta as ta and use df.ta.<indicator>() calls instead of ta.trend.<thing>().

‚ùå Issue 3: Not Enough Data
Screeners assume 200+ days of history, but data_dict might only contain 30 or fewer rows.

‚úÖ Fix: Add safe guards:

python
Copy
Edit
if len(df) < 125:
    continue
‚úÖ And make sure if data_dict is empty or incomplete, you fetch data directly inside the screener.

‚úÖ Solution: Adapted SCTR Clone Screener (Self-Loading, pandas-ta Compatible)
Here‚Äôs an updated screener that:

‚úÖ Uses pandas-ta correctly

‚úÖ Fetches data if it‚Äôs not already loaded

‚úÖ Works with minimal history

‚úÖ Outputs flushed, JSON-wrapped results

python
Copy
Edit
import yfinance as yf
import pandas as pd
import pandas_ta as ta
import json
import sys

class SCTRCloneScreener:
    def __init__(self, symbols=None):
        self.symbols = symbols or ["AAPL", "MSFT", "TSLA", "NVDA", "AMD", "META", "GOOGL"]

    def fetch_data(self, symbol):
        try:
            df = yf.download(symbol, period="6mo", progress=False)
            if df.empty or len(df) < 125:
                return None
            df.ta.ema(length=200, append=True)
            df.ta.ema(length=50, append=True)
            df.ta.roc(length=125, append=True)
            df.ta.roc(length=20, append=True)
            df.ta.rsi(length=14, append=True)
            df.ta.ppo(append=True)
            df["ppo_slope_3d"] = df["PPOh_12_26_9"].diff().rolling(3).mean()
            return df
        except Exception as e:
            print(f"Error fetching {symbol}: {e}")
            return None

    def calculate_sctr(self, row):
        score = 0
        score += 30 if row["Close"] > row["EMA_200"] else 0
        score += min(max(row["ROC_125"], 0), 30)
        score += 15 if row["Close"] > row["EMA_50"] else 0
        score += min(max(row["ROC_20"], 0), 15)
        score += 5 if row["ppo_slope_3d"] > 0 else 0
        score += min(max(row["RSI_14"] / 100 * 5, 0), 5)
        return round(min(score, 99.9), 2)

    def run(self):
        matches = []
        for symbol in self.symbols:
            df = self.fetch_data(symbol)
            if df is None or df.empty:
                continue
            latest = df.iloc[-1]
            try:
                score = self.calculate_sctr(latest)
                matches.append({
                    "symbol": symbol,
                    "price": round(latest["Close"], 2),
                    "score": score,
                    "rsi": round(latest["RSI_14"], 1),
                    "details": f"SCTR {score}, RSI {round(latest['RSI_14'],1)}"
                })
            except Exception as e:
                print(f"Error scoring {symbol}: {e}")
                continue
        return matches

# REQUIRED ENTRY POINT
def screen_stocks(data_dict):
    screener = SCTRCloneScreener()
    matches = screener.run()

    result = {
        "matches": [m["symbol"] for m in matches],
        "details": {m["symbol"]: m for m in matches}
    }

    print("RESULT_JSON_START")
    print(json.dumps(result))
    print("RESULT_JSON_END")
    sys.stdout.flush()
    return result
‚úÖ What This Solves
Problem	Fixed By
dict has no attribute 'empty'	Data is now fetched via yfinance inside the screener
ta.trend.ppo doesn't exist	Using pandas_ta.ppo() instead
Not enough data	Period is 6mo, and screener skips short series
JSON not parsed	Uses print(...), sys.stdout.flush() ‚úÖ

